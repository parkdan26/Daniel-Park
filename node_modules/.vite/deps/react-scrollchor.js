import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-I4MZPW7S.js";

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "node_modules/performance-now/lib/performance-now.js"(exports, module) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return (/* @__PURE__ */ new Date()).getTime() - loadTime;
        };
        loadTime = (/* @__PURE__ */ new Date()).getTime();
      }
    }).call(exports);
  }
});

// node_modules/raf/index.js
var require_raf = __commonJS({
  "node_modules/raf/index.js"(exports, module) {
    var now = require_performance_now();
    var root = typeof window === "undefined" ? global : window;
    var vendors = ["moz", "webkit"];
    var suffix = "AnimationFrame";
    var raf2 = root["request" + suffix];
    var caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
    for (i2 = 0; !raf2 && i2 < vendors.length; i2++) {
      raf2 = root[vendors[i2] + "Request" + suffix];
      caf = root[vendors[i2] + "Cancel" + suffix] || root[vendors[i2] + "CancelRequest" + suffix];
    }
    var i2;
    if (!raf2 || !caf) {
      last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
      raf2 = function(callback) {
        if (queue.length === 0) {
          var _now = now(), next = Math.max(0, frameDuration - (_now - last));
          last = next + _now;
          setTimeout(function() {
            var cp = queue.slice(0);
            queue.length = 0;
            for (var i3 = 0; i3 < cp.length; i3++) {
              if (!cp[i3].cancelled) {
                try {
                  cp[i3].callback(last);
                } catch (e) {
                  setTimeout(function() {
                    throw e;
                  }, 0);
                }
              }
            }
          }, Math.round(next));
        }
        queue.push({
          handle: ++id,
          callback,
          cancelled: false
        });
        return id;
      };
      caf = function(handle) {
        for (var i3 = 0; i3 < queue.length; i3++) {
          if (queue[i3].handle === handle) {
            queue[i3].cancelled = true;
          }
        }
      };
    }
    var last;
    var id;
    var queue;
    var frameDuration;
    module.exports = function(fn) {
      return raf2.call(root, fn);
    };
    module.exports.cancel = function() {
      caf.apply(root, arguments);
    };
    module.exports.polyfill = function(object) {
      if (!object) {
        object = root;
      }
      object.requestAnimationFrame = raf2;
      object.cancelAnimationFrame = caf;
    };
  }
});

// node_modules/requestanimationframe-timer/module/index.js
var import_raf = __toESM(require_raf());
var MODE;
(function(MODE2) {
  MODE2[MODE2["MODE_TIMEOUT"] = 0] = "MODE_TIMEOUT";
  MODE2[MODE2["MODE_INTERVAL"] = 1] = "MODE_INTERVAL";
})(MODE || (MODE = {}));
var fnMap = /* @__PURE__ */ new Map();
var executionSet = /* @__PURE__ */ new Set();
var rafStarted = false;
var startId = 0;
function getTimeStamp() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function executeFn(value) {
  const { fn, args } = value;
  fn(...args);
}
function runFunction() {
  if (executionSet.size === 0)
    return;
  executionSet.forEach(executeFn);
  executionSet.clear();
}
var checkTick = (currentTimeTick) => (value, id) => {
  const { nextTick, ms, mode } = value;
  if (currentTimeTick - nextTick >= 0) {
    executionSet.add(value);
    if (mode === MODE.MODE_TIMEOUT) {
      fnMap.delete(id);
    } else {
      fnMap.set(id, {
        ...value,
        nextTick: nextTick + ms
      });
    }
  }
};
function loop() {
  if (fnMap.size === 0) {
    rafStarted = false;
    return;
  }
  const currentTimeTick = getTimeStamp();
  fnMap.forEach(checkTick(currentTimeTick));
  runFunction();
  if (fnMap.size === 0) {
    rafStarted = false;
    return;
  }
  (0, import_raf.default)(loop);
}
function addId({ fn, ms, args, mode }) {
  if (!fn)
    return null;
  const currentId = startId;
  fnMap.set(currentId, {
    fn,
    ms,
    nextTick: getTimeStamp() + ms,
    args,
    mode
  });
  if (!rafStarted) {
    rafStarted = true;
    (0, import_raf.default)(loop);
  }
  startId += 1;
  return currentId;
}
function removeId(id) {
  if (id == null)
    return;
  if (fnMap.has(id)) {
    fnMap.delete(id);
  }
}
var setTimeout2 = (fn, ms = 0, ...args) => addId({ fn, ms, args, mode: MODE.MODE_TIMEOUT });
var clearTimeout = removeId;

// node_modules/react-scrollchor/lib/scrollchor.es.js
var import_react = __toESM(require_react());
var i = (t) => t;
var c = (t) => 0.5 - Math.cos(t * Math.PI) / 2;
var a = (t, e, n2, o2, r2) => {
  const i2 = e / r2;
  return -o2 * i2 * (i2 - 2) + n2;
};
var l = /* @__PURE__ */ (() => {
  let n2, o2;
  return (r2, i2, c2) => {
    let a2;
    if ("" !== i2) try {
      const t = document.getElementById(i2);
      null !== t && (a2 = t);
    } catch (t) {
      console.error(`Failed to get element by id ${i2}, falling back to default`);
    }
    function l2() {
      return a2 ? a2.scrollTop : document.documentElement.scrollTop || document.body.scrollTop;
    }
    return new Promise((i3, s2) => {
      const u2 = r2 ? document.getElementById(r2) : document.body;
      if (!u2) return void s2(new Error(`Cannot find element: #${r2}`));
      const { offset: f2, duration: d, easing: m } = c2, p = Date.now(), y = l2(), g = function(t) {
        const e = a2 ? a2.getBoundingClientRect().top : 0;
        return t.getBoundingClientRect().top - e + l2();
      }(u2) + f2;
      n2 && (clearTimeout(n2), o2()), o2 = i3, function e() {
        const o3 = Date.now(), c3 = 1 - (Math.max(0, p + d - o3) / d || 0), l3 = m(c3, d * c3, 0, 1, d);
        var s3;
        if (s3 = (g - y) * l3 + y, a2 ? a2.scrollTop = s3 : (document.documentElement.scrollTop = s3, document.body.scrollTop = s3), c3 < 1) {
          n2 = setTimeout2(e, 20);
        } else n2 = void 0, i3(r2);
      }();
    });
  };
})();
function s(t) {
  const e = `#${t}`;
  "function" == typeof window.history.pushState ? window.history.pushState({}, "", e) : window.location.hash = e;
}
function u(t) {
  return "string" == typeof t ? t.replace(/^#/, "") : "";
}
var f = (t) => {
  var { to: e, target: i2, animate: c2 = {}, beforeAnimate: f2, afterAnimate: d, disableHistory: m = false, children: p } = t, y = function(t2, e2) {
    var n2 = {};
    for (var o2 in t2) Object.prototype.hasOwnProperty.call(t2, o2) && e2.indexOf(o2) < 0 && (n2[o2] = t2[o2]);
    if (null != t2 && "function" == typeof Object.getOwnPropertySymbols) {
      var r2 = 0;
      for (o2 = Object.getOwnPropertySymbols(t2); r2 < o2.length; r2++) e2.indexOf(o2[r2]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, o2[r2]) && (n2[o2[r2]] = t2[o2[r2]]);
    }
    return n2;
  }(t, ["to", "target", "animate", "beforeAnimate", "afterAnimate", "disableHistory", "children"]);
  const g = (0, import_react.useMemo)(() => u(e), [e]), b = (0, import_react.useMemo)(() => u(i2), [i2]), h = (0, import_react.useMemo)(() => {
    const { offset: t2 = 0, duration: e2 = 400, easing: n2 = a } = c2;
    return { offset: t2, duration: e2, easing: n2 };
  }, [c2]), w = (0, import_react.useCallback)((t2) => {
    f2 && f2(t2), t2.preventDefault(), l(g, b, h).then((e2) => {
      e2 && (m || s(e2), d && d(t2));
    });
  }, [d, h, f2, m, b, g]);
  return p ? import_react.default.createElement("a", Object.assign({ href: `#${g}`, onClick: w }, y), p) : null;
};
export {
  f as Scrollchor,
  l as animateScroll,
  a as easeOutQuad,
  i as linear,
  u as normalizeId,
  c as swing,
  s as updateHistory
};
/*! Bundled license information:

react-scrollchor/lib/scrollchor.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=react-scrollchor.js.map
